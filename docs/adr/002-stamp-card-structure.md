# 002. スタンプカード機能のデータ構造 (3層構造)

## Context
当初、スタンプカード機能は `stamp_cards` (設定) と `user_stamps` (履歴ログ) の2テーブルで構成し、現在のスタンプ数はログのカウント（集計）によって算出する設計としていた。
しかし、以下の課題が想定された：
1. **パフォーマンス**: ユーザーが増えるにつれて集計コストが増大する。
2. **状態管理の複雑さ**: 「特典交換済み」や「有効期限切れ」などの状態をログの集合から判断するのは複雑であり、バグの温床となりやすい。
3. **UX**: ユーザーは「今何個持っているか」という状態（Wallet的な概念）に関心がある。

## Decision
スタンプカード機能を以下の3層構造（店舗(1) → テンプレート(1) → ユーザー所持カード(多)）に再定義し、状態と履歴を分離する。

1. **Shop (店舗)**
   - 基点となるエンティティ。

2. **Stamp Card Template (`stamp_cards`)**
   - 店舗が定義するスタンプカードのルール（目標数、特典、期限など）。
   - 1店舗につき1つ (1:1 with Shop)。
   - PK: `shop_id` (または `id` -> `shop_id`)。

3. **User Stamp Card (`user_stamps`)**
   - ユーザーが所持しているスタンプカードの**現在の状態**を管理する。
   - 1ユーザー×1店舗につき1つ (User:Shop = N:N)。
   - カラム: `current_count`, `is_completed`, `updated_at` 等。
   - これにより、「マイカード一覧」の表示やスタンプ数の取得が O(1) で可能になる。

4. **Stamp Logs (`stamp_logs`)**
   - スタンプ獲得のアクション履歴。
   - `user_stamps` の子テーブルとして存在。
   - 不正検知（位置情報チェック）、分析、トラブルシューティングに使用。

## Consequences
- **Positive**:
  - クエリが単純化され、一覧表示のパフォーマンスが向上する。
  - 「特典交換済み」フラグなどで状態管理が明確になる。
- **Negative**:
  - スタンプ付与時に `user_stamps` (UPDATE) と `stamp_logs` (INSERT) の2つの書き込みが必要になる（トランザクション推奨）。
  - 既存の実装（ログ集計方式）からの移行コストが発生する（今回は初期段階のため許容）。

## Status
Accepted
